token KW_TOKEN = "token";
token KW_ENTRY = "entry";
token KW_PROD = "prod";
token EQUALS = "=";
token SEMI = ";";
token LPAR = "(";
token RPAR = ")";
token LBRACK = "[";
token RBRACK = "]";
token DIGIT = /(0|[1-9][0-9]*)/;
token QUESTION = "?";
token NOTHING = "!";
token ASTERISK = "*";
token PLUS = "+";
token PIPE = "|";
token IDENT = /[a-zA-Z][a-zA-Z0-9_]*/;
token STRING = /"([^"\\\n]|\\.)*"/;
token REGEX = /\/([^\/\\\n]|\\.)*\//;
token WHITESPACE = /[ \t]+/;
token NEWLINE = /[\n]/;

entry rules;
prod rules = rule;
prod rules = rule rules;
prod rule = entry_rule;
prod rule = prod_rule;
prod rule = token_rule;
prod entry_rule = KW_ENTRY IDENT SEMI;
prod prod_rule = KW_PROD IDENT (tag)? EQUALS pattern SEMI;
prod token_rule = KW_TOKEN IDENT (precedence)? EQUALS string_or_regex SEMI;
prod precedence = LBRACK DIGIT RBRACK;
prod tag = LBRACK IDENT RBRACK;
prod string_or_regex = REGEX;
prod string_or_regex = STRING;
prod pattern = alternative;
prod pattern = NOTHING;
prod alternative = concatenation PIPE alternative;
prod alternative = concatenation;
prod concatenation = unary concatenation;
prod concatenation = unary;
prod unary = option;
prod unary = repetition_one;
prod unary = repetition_zero;
prod unary = item;
prod option = item QUESTION;
prod repetition_zero = item ASTERISK;
prod repetition_one = item PLUS;
prod item = IDENT;
prod item = LPAR pattern RPAR;